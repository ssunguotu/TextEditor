# Bloom Filter实现及思路

摘录自：

1. https://www.cnblogs.com/z941030/p/9218356.html

2. https://www.cnblogs.com/CodeBear/p/10911177.html

这两篇文章思路十分清晰。

---

[TOC]



## Bloom Filter 引入

如果想判断一个元素是不是在一个集合里，一般想到的是**将集合中所有元素保存起来**，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路，存储位置要么是磁盘，要么是内存。很多时候要么是以时间换空间，要么是以空间换时间。

在响应时间要求比较严格的情况下，如果我们存在内里，那么随着集合中元素的增加，我们需要的存储空间越来越大，以及检索的时间越来越长，导致内存开销太大、时间效率变低。



### 缓存穿透

我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。
虽然有很多办法都可以解决这问题，但是我们的主角是“布隆过滤器”，没错，“布隆过滤器”就可以解决（缓解）缓存穿透问题。至于为什么说是“缓解”？



### 大量数据，判断给定的是否在其中

现在有大量的数据，而这些数据的大小已经远远超出了服务器的内存，现在再给你一个数据，如何判断给你的数据在不在其中。如果服务器的内存足够大，那么用HashMap是一个不错的解决方案，理论上的时间复杂度可以达到O(1)，但是现在数据的大小已经远远超出了服务器的内存，所以无法使用HashMap，这个时候就可以使用“布隆过滤器”来解决这个问题。但是还是同样的，**会有一定的“误判率”。** 



总结：在数据量比较大的情况下，既满足时间要求，又满足空间的要求。即我们需要一个时间和空间消耗都比较小的数据结构和算法。Bloom Filter就是一种解决方案。



## Bloom Filter 原理

布隆过滤器的原理是：

添加时：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。

检索时：我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。

这就是布隆过滤器的基本思想。

Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。

![img](https://images2018.cnblogs.com/blog/740591/201806/740591-20180623183045586-692673875.jpg)



## Bloom Filter 优缺点

优点是显而易见的，对于完成检索某数据是否在集合中的这种操作，使用布隆过滤器后可以使得集合中并不用真的保存这些数据，只需保存一个二进制序列即可，故使得空间复杂度降低；同时只用数个哈希函数来查表，实际复杂度为O（1）；



但是bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性

- 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。

- 删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用[Counting Bloom Filter](http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2)

 

但是对于一个只实现给关键字特殊标识的文本编辑器，可以轻松的建立白名单，且没有删除的困难。



## Bloom Filter 实现

在使用bloom filter时，绕不过的两点是**预估数据量n**以及**期望的误判率fpp**，

在实现bloom filter时，绕不过的两点就是**hash函数的选取**以及**bit数组**的大小。

 

对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数。



### (1)Bit数组大小选择 

根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式:


$$
m = - \frac{n\ln fpp}{(\ln 2)^2}
$$
对于课设，将n设置为：50（c99中关键字大概有37个），fpp设置为0.01，即1%的概率。

计算得 **m = 479.2529，取480.**



### (2)哈希函数选择

**对于数量的选择：**

由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：
$$
k = \frac {m}{n}ln 2
$$
得到 **k = 6.6439，取7.**



**对于函数实现的选择：**

评价哈希函数优劣的因素有：
能否将关键字均匀影射到哈希空间上，
有无好的解决冲突的方法，
计算哈希函数是否简单高效。



哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是**选择一个哈希函数，然后送入k个不同的参数**。







引用：

1. http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html

2. https://en.wikipedia.org/wiki/Bloom_filter







# TIPS：

将关键字分类，一个类型使用一个filter。



用python实现吧，hash函数使用murmurhash3 ，图形化使用pyqt